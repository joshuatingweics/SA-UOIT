<!DOCTYPE html><html><body><ul><li>finals<ul><li>download a offline version of this </li><li>week1<ul><li>design a software system that addresses the quality attributes of the requirements (non functional requirements )</li><li>the big picture</li><li>how to measure and analyse an architecture good or bad?</li><li>architecture is the key design decisions, that are not low level..</li><li>architectecture is the principal decisions regarding its design , the key abstractions that characterize the application</li><li>is about requirements of the application</li><li>architecture is an evolving body of information</li><li>architecture is like the blueprint , so would just go for trial and error</li><li>assess if it is consistent(mismatched components, missing info), correct and exhibit desired nonfunctional properties, consistent with requirements</li><li>used to understand the code quickly , help in testing strategies to source code</li><li>it is very expensive to reverse engineer the code back to architecture, so just maintain architecture at all times.</li><li>can use automatic code generation or use frameworks ( then architecture will be as clear as day )</li><li>framework will influence architectural choices</li><li>middleware platforms also influence the architecture..</li><li>middleware is the software that connects software components... </li><li>middleware technologies such as CORBA, COM, and RMI provide a set of predefined services for enabling component composition and interaction. However, the potential role of such services in the implementations of software architectures is not well understood. In practice, middleware can resolve various types of component heterogeneity — across platform and language boundaries, for instance — but also can induce unwanted architectural constraints on application development. </li><li>components communicate through architecture-level software connectors that are implemented using middleware.</li><li></li><li>scenario based:</li><li>use-case diagram</li><li>activity diagram</li><li></li><li>flow-oriented :</li><li>control-flow diagram</li><li></li><li>class based:</li><li>class diagram</li><li></li><li>behavior:</li><li>sequence diagram</li><li>state diagram</li><li></li></ul></li><li>week2<ul><li>software architecture--structure with elements,relationships among elements and properties of both elements and relationships...</li><li>a view -- is like from a perspective , what u can see</li><li>A reference architecture is the set of principal design decisions that are simultaneously applicable to multiple related systems, </li><li>typically <b>within an application domain</b>, with explicitly deﬁned points of variation ( something that he will test )</li><li>Reference architectures are standardized architectures that provide a frame of reference for a particular domain, sector or field of interest. </li><li>Reference models or architectures provide a common vocabulary, reusable designs and industry best practices.</li><li>not used directly, used as a constraint for more concrete architectures</li><li></li><li>design decisions on : structure, functional behavior, interaction, non functional requirements and implementation</li><li></li><li>software components --(i) something that has some functionality or data (ii)has interface to access to data and functionality (iii)has explicitly defined dependencies (iv)packaged objects, ease for usage,can be deployed</li><li>what is interface exactly?</li><li>software connectors: something that effecting and regulating interactions between components</li><li>there are different types of connectors ....when to use which one?</li><li>what is architecture configuration? a set of specfic associations between the components and connectors</li><li></li><li>architecture patterns--collection of architectural design decisions ( used for recurring design problem )<ul><li>3 tier architecture---used in distributed systems</li></ul></li><li>architecture is captured using architecture model using a notation--can capture different perspective ( structural , behavioral, static ,dynamic , entire system or a small part )</li><li>model-- the documentation of the design decisions</li><li></li><li>when u achieve one quality attribute, it might lead to negative to another one...</li><li>why architecture is impt ?</li><li></li><li>should base the architecture on a prioritized list of well-specified quality attribute requirements. </li><li>•The architecture should be evaluated for its ability to deliver the system’s important quality attributes. </li><li>–Create a “skeletal” system in which the communication paths are exercised but which at first has minimal functionality. ( incremental implmentation )</li><li></li><li></li><li>The information-hiding modules should encapsulate things likely to change (like what? )</li><li>Each module should have a well-defined interface that encapsulates or “hides” the changeable aspects from other software </li><li></li><li>quality attributes should be achieved using patterns and tactics specific to each attribute (???)</li><li>Modules that produce data should be separate from modules that consume data. ( usually u either change the consumption or the production side at one point of time )</li><li></li><li>module structure---how system is structured as a set of code that have to be constructed</li><li>component-and-connector structure --- how system is structured as a set of components(have runtime behavior) and interactions(connectors)</li><li>deployment structure --- how system relate to non software structure(such as CPUs, file systems, networks...) in its envt(the system's) --- </li></ul></li><li>week3<ul><li>what is modeling? the way to capture design decisions</li><li>what design decisions? how to organize the design decisions?</li><li>connectors are elements(box itself) in between components</li><li>interfaces is attached to the connectors and components themselves....interface is part of themselves</li><li>configurations--basically is like how software components and connectors connected to one another , how they work tgt, whats their relationships</li><li></li><li>what are the constraints(interaction, behavioral and concurrency wise ) ( should model in --but how ? )</li><li>what are the component, connector and interface TYPES?</li><li></li><li>functional requirement: the system prints medical records</li><li>non functional: prints medical records quickly and confidentially</li><li></li><li>when u model things in a certain way--you should have your own reasoning for doing so!!!</li><li></li><li>view--is a subset of model</li><li>viewpoint---is a concern</li><li>there are different viewpoints(for a particular concern):--all of them is coordinated to capture all the deisgn decisions</li><li>page 14 onwards</li><li>logical</li><li>physical</li><li>deployment</li><li></li><li>there might be inconsistency in the views:</li><li>a component in a sequence diagram does not exists in component diagram</li><li>and many more</li><li></li><li>when u have a quality attribute, u state the requirements , u should know exactly what u should implement to achieve that... like for performance what u should do... for reliability what u should do? </li><li></li><li></li><li>how u should model:</li><li>–The (name) interface on (name) component takes (list-of-elements) as input and produces (list-of-elements) as output (synchronously | asynchronously).</li><li></li><li>mainly going to use UML to model the software system (what i going to do tmr )</li><li>page 40 onwards </li><li>component diagram</li><li>sequence diagram</li></ul></li><li>week4 connectors<ul><li>components may not connect well too each other ( the format of  data and control flow )--so the components cant work tgt</li><li>a connector is used to integrate the 2 components ( so that they can work tgt )</li><li>connector dont do computation, components do the computation</li><li>connectors provide protocols , some storage( like buffer )</li><li>connector does the mediator job ....( to filter, to rearrange, to change format, connector needs to understand the 2 languages spoken by the 2 components )</li><li>purpose of a connector: is to make the 2 components work tgt, it does not help the system functionality ...( component does the system functionality )</li><li>connector is only required when u know there is an mismatch of components</li><li>connector u see on digram is one box(software architecture), but in implementation, it usually integrated with components, does not have itself as a unit,no identity...</li><li></li><li>with connectors--- u can specify :</li><li>interaction abstraction or parameterization</li><li>specification of complex interactions : binary vs N-ary, assymetric vs symmetric , interaction protocols....</li><li></li><li>what are some properties of the connection u want to convey through connectors?</li><li>i stopped at slide 11</li><li></li><li>there are 4 types of connectors: different types of connectors provide different services </li><li>communication --transmission of data<ul><li>invocation( the parameter is being transferred )</li></ul></li><li>coordination -- transfer of control <ul><li>acknowledgement </li><li>guaranteed delivery (retry)</li><li>transactions</li><li>invocation </li><li>multiplexing </li><li>synchronization </li><li>scheduling </li></ul></li><li>conversion -- converting data formats so that components can interact</li><li>facilitation -- some kind of mediation or operation optimization activity <ul><li>data buffering -- making the system work better</li><li>dynamic reconfiguration -- making a system run better at runtime</li><li>load balancing </li></ul></li><li></li><li>different kinds of connectors :</li><li>procedural call ---there is a flow of control, thus is a coordination  connector ....shift the control from calling routine to the called routine...there is a transmission of data via the parameters</li><li>usually we think of it as synchronous ... but it can be assychronous</li><li>is it accessible ?</li><li></li><li></li><li></li><li></li><li></li><li></li><li>what are interaction protocols? why are they being used?</li><li></li><li></li></ul></li><li>week5 architecture pattern and style<ul><li>lessons learnt from others </li><li>design pattern( more implementation level, low level) vs architecture pattern( more on design decisions,structure, the big idea )</li><li>some software architecture are good at certain domains, has many successful applications using that architecture</li><li>architectural patterns -- set of architectural design decisions ( for a recurring design problem ), u can parameterized to account for different context in which that problem appears....</li><li></li><li>what are the architecture pattern? </li><li>3-tiered pattern<ul><li>MVC ( cfm come out )<ul><li>when should i use them?</li><li></li><li>model -- –realize problem-domain function--•Holds data and operations for achieving the computational goals of the program independent of its user interface</li><li>view -- a way to display a component -- •Data displayed in views come directly from one or more models (i.e. labels and graphics)</li><li>controller -- –Components receive and carry out commands from users ( buttons and scrollbar to let user to play )</li><li>slide 10</li><li></li><li>static structure: uses layered style (slide 11)</li><li>dynamic structure: slide 12 and 13</li><li>advantages and disadvantages</li><li></li></ul></li></ul></li><li></li><li>what are the architecture styles?</li><li>less domain specifity than architecture patterns </li><li>basic properties of style: design element, data elements , configurations rules( how u arrange the different elements ), semantic interpretation</li><li>comon styles<br>within the style, there are architecture patterns <ul><li>traditional:</li><li>main program and subroutine</li><li><b>object oriented style</b><br>results from object oriented programming paradigm<br>when u choose java, u are not just choosing a language, u are choosing how u solve problems as well.. <br>	<ul><li>division of responsibilities into individual reusable and self - sufficient objects</li><li>oo architectural style is focused on the data</li><li> look at the different kinds of data handled by the system 1st</li><li>see how the system can be broken down into abstract data types(a abstract data type can be represented by a class--so that related attributes and methods are grouped tgt  )</li><li></li><li>there are object oriented patterns: creational , structural and behavioral categories</li></ul></li><li></li><li><b>layered:</b><ul><li>a grouping of functionality into distinct layers that are stacked vertically on top of each other </li><li>communication between layers is explicit and loosly coupled</li><li></li><li>security: </li><li>good becuz it is easier to add a security layer between the system and its environment </li><li></li><li>performance:</li><li>reduced slightly becuz the response to external events must be passed up and down the layers , which increase context swapping</li><li></li><li>maintainability:</li><li>improved becuz of the stable interlayer protocols and interfaces , which would lead to well-defined and reusable components</li><li> </li><li>reliability: </li><li>reduced as an event may be handled in multiple layers , making it hard to find which is the responsible layer </li><li></li><li></li><li>usually is the bottom one provide services to the <b>adjacent</b>  higher level..</li><li>a layer is a collection of components that work tgt towards a common purpose... thus <b>within a layer</b>, components do communicate with one another </li><li>higher level request from lower layer , the lower layer could signal a layer above an event</li><li>the interfaces provided by the components of layer should be well-defined </li><li></li><li>advantages: (layering)</li><li>separation of concerns: presentation , logic and data </li><li>users can perform complex tasks without understanding the layers below</li><li>different layers can be run at different levels of authorization or privilege-- the top layer has no authority over the most bottom layer---security</li><li>loosely coupled -- the pinciple of least knowledge( when u replace a layer u just need to ensure that its interface with the layer above is consistent with the previous implmentation</li><li></li><li>disadvantages: </li><li>not very easily mapped to layered, becuz principal might want to talk to students (skip layers)</li><li>sometimes u just need one layer to talk to the all other layers as well</li><li>becuz u only can communicate with adjacent layers--u just pass information ---leading to overhead, uses processing resources, which lead to dip in performance</li><li>if only just a small amount of information just pass through a layer without anything done to it, then its okay to use layered architecture </li></ul></li><li>VMs</li><li>client - server ( n-tier )<ul><li>anytime a system can be split into service roles and requestor roles , this architecture can be considered</li><li>usually this architecture are used slightly different from layered architecture ( even though different layers, but still on the same machine )</li><li>tiers are often refer to components that are on different physical machines</li><li></li><li>server side provide services , storing information in a DB, perform computation</li><li>client side requests these services through messages </li><li>communication: request - response</li><li>the server does not know how many clients it may have</li><li></li><li>media server, web server , application server , file server ,print server </li><li></li><li>sequences diagram usually have request ( solid line ) and response ( as the dashed line )</li><li>then there are different requests available ( view playlist , play selection )on the lifeline </li><li></li><li>the request-response relationship between a client and a server can be synchronous or asynchronous</li><li>synchronous: client send request and wait for response before continuing execution ( depicted with a closed arrow head )</li><li>better responsive with asynchronous : client send a request but control returns right away so client can continue processing another need ( depicted with a line and a arrowhead )</li><li></li><li></li><li>advantages:(request-response)---2 tier feels like blackboard </li><li>easily scalable to add more clients </li><li>server is passive , when the clients requires information, they will request</li><li> in an application/middle/business tier in between database and the end users </li><li>application tier determine how and when data can be changed and in what ways ( where all the logic lies )-- so client software can just focus on presentation , easier to maintain as a result</li><li>levels of abstraction </li><li>loose coupling ( easier to change and extend )</li><li></li><li>few drawbacks:</li><li>demand extra resources to manage this </li><li>adding more tier means adding more machines and processes to manage</li><li>due to different communication protocols used , it makes the system more difficult to change or maintain</li><li>a server acts as a central point of failure</li></ul></li><li></li><li>data-flow styles:</li><li>batch sequential</li><li><b>pipe and filter</b><ul><li>a chain of processing elements (filters ) arranged so that the output of each element is communicated via a pipe to become of the input of the next </li><li>for stream processing </li><li>filter(components)(box)-- computation</li><li>data flows through a chain of filters(represents the system)</li><li></li><li></li><li>performance:</li><li>can enhance throughput becuz the filters  can run in parallel</li><li>but individual filter may be slowed down if it is waiting for its supplier ( so the processing time for each filter should try to set it to be the same, so that there will be less waiting time )</li><li></li><li>mainatbility:</li><li>each of the filters are independent unit and this enhances encapsulation and reusability </li><li>but the data format of the filters must be the same, as a result the coupling is higher</li><li></li><li>reliability:</li><li>may be reduced due to the weakest link filter ( if one pipe or filter breaks down , then the whole application breaks down )</li><li></li><li>safey: </li><li>easier to verify becuz all of the output comes from a single source</li><li></li><li>security: </li><li>simplicity increases opportunities for authetication , encryption and implementation of security levels</li><li></li><li>A series of transformation on sets of data</li><li>filters perform transformations on data input they receive</li><li>pipes serve as connectors for the stream of data being transformed </li><li>always started out with a data source </li><li>data flows in one direction </li></ul></li><li></li><li></li><li>shared memory</li><li><b>Blackboard</b><ul><li>do your users need to share a set of data?</li><li>how large is your user base? -- if not alot, dont need this one la, too costly...</li><li></li><li>common knowlegde base is iteratively updated by a diverse group of specialist knowledge sources, starting with a problem specification and ending with a solution</li><li></li><li>create a software architecture that is capable of sharing info between separate components..</li><li>problem we need to adress: </li><li>the state of the component is temporary while the component is running ( data persistence issue )</li><li>the need to communicae the state of our data between multiple components</li><li>this architecture : help to store and share data between multiple components, it helps increase the maintainability ,reusability and scalability</li><li></li><li>2 components : central data( store and serve data across all components that connect to it ) and data accessors ( connect to the central data )</li><li>central data -- is passive ( they also dont do heavy data processing / business logic )</li><li>data accessors do query, they are components that connect to the central data ( database ), they do not know other data accessors , get data to perform computations, able to save the new state of system back into the database using transactions</li><li>often, central data is stored in a database</li><li></li><li>advantages ( centralized database ):</li><li>data integrity </li><li>data backup</li><li>data restoration </li><li>there is no overhead for communicating with other data accessors, they communicate indirectly through the central data...</li><li>can be easily scaled up, without having to worry abt affecting the others data accessors </li><li>separate the functionality of your data accessors</li><li></li><li>disadvantages:</li><li>heavily reliant on the central data component</li><li>data accessors are dependent on the central data, u need to build them around the existing data schema-- thus difficult to change the existing data schema in future</li><li></li></ul></li><li></li><li>implicit invocation:</li><li>event based </li><li><b>publisher subscriber</b><ul><li>a component can broadcast events, other components in the system can register interest by associating a procedure with the event...</li><li>advantages: ( cuz of one way communication )</li><li>very scalable - new components can just register themselves</li><li></li></ul></li></ul></li><li>design pattern</li><li>stopped at slide 25 </li></ul></li><li>week6 architecture design ( based on requirements such as quality attributes )<ul><li>based on architectural requirements, drivers ( such as design purpose, quality attributes, primary functions, architecture concerns, constraints )</li><li></li><li>there are many alternatives, choose the right one</li><li>Type of connectors ?</li><li>what components to use ? define what the component do</li><li>define interaction between elements ( what do they talk about ) </li><li>slide 4 ( dont know if useful not )</li><li></li><li>architecture decision--matter to the achievement of architectural drivers ( mentioned above )</li><li></li><li>what decisions do we make to achieve quality attributes ? </li><li>quality attributes: <ul><li>Interoperability</li><li>Modifiability</li><li>Performance -- the timeliness of the service delivered by the system<ul><li>response time, throughput , capacity , utilization</li></ul></li><li>Testability -- how easy is to create test criteria for the system and its components, and to execute these tests that assess if the criteria are met</li><li>Security -- prevent actions that arent following designed usage.. ability to protect data and information from unauthorized access while still providing access to people and systems that are authorized.</li><li>Usability -- how easy for user to accomplish a task? and is there user support provided by system</li><li>maintability --extent to which enhancements can be readily added to a system <ul><li>how to measure : coupling and cohesion </li><li>how to achieve : encapsulation , publish interfaces , subclassing , indirection and wrapping</li></ul></li></ul></li><li>measurable / testabe properties of a system </li><li>comes from prioritized list of scenarios, aligned with business goals </li><li><ul><li>utility tree--important <ul><li>a way to record all ASRs in one place</li><li>ASRs are captured as scenarios </li><li></li><li>there is a priority of each ASR based on (i) impact on architecture and (ii) business value</li><li></li><li>root of tree is "utility"</li><li>2nd level contains broad QA categories</li><li>3 level is the refine</li><li>an example : is slide 11</li><li></li><li>quality attributes :<ul><li>Functional Suitability</li><li>Performance Efficiency</li><li>Compatibility</li><li>Usability</li><li>Reliability</li><li>Security</li><li>Maintainability</li><li>Portability</li></ul></li></ul></li></ul></li></ul></li><li>week7 design process( what steps to take while designing architecture, means when u make decisions, what are the steps should u take )--stopped at slide 4<ul><li>systematic way of making decisions so that the decisions can be justified in the future</li><li>ADD method -- attribute driven design method</li><li>essence: iterative </li><li>each iteration you choose a part to design </li><li>find all the ASR( architecturally significant requirements for that part )</li><li>generate and test a design for that part </li></ul></li><li>week8 (determine if this architecture is good enough )<ul><li>ATAM method -- architecture tradeoff analysis method </li><li>help to choose a suitable architecture for a software system by discovering tradeoffs and sensitivity points</li><li>relies heavily on scenarios that exercise critical parts of the system </li><li>structured method for considering how the architecture handles a range of scenarios </li><li>a scenario where the system should not fail, should cause competing qualities ( security vs usability )</li><li>what kind of things u will compromise?</li><li>start with architecture 1st ....then u have the scenarios to check the architecture ...</li><li>what are the architectural decisions that u have made to the quality requirements ?</li><li>when u describe your quality attributes-- describe it in terms of scenarios...</li><li>write down risks and nonrisks</li><li></li><li></li><li>what are some of the tradeoffs ? ( when u choose to do one thing , u sacrifice something )</li><li>usually u need to be specific in what u do, then u know what u sacrifice ...cause and consequences....</li><li>there will be some constraints somewhere .... </li><li></li></ul></li><li>week9</li><li>week10 designing for NF properties<ul><li>constraints on the manner in which the system delivers its functionality </li><li>Non functional properties have to be seen in all components / connectors in order for it to be exhibited ...</li><li></li><li>NFP affects the user experience !!!</li><li></li><li>efficiency -- a quality that reflects a software system's ability to meet its performance requirements while minimizing its usage of the resources in its computing envt</li><li>efficiency starts at the architectural level</li><li></li><li>slide 9: </li><li>off the shelf component might have too many function that are not required</li><li>one component shouldnt do too many things by itself--it might slow down the entire process</li><li>separate data components from processing components <br>when u change one, usually u dun change another</li><li>build a component(functionality) with multiple interfaces <br>u dun need replicate components that have the same functions, most of the time software components are built to be usable in muliple run time contexts, should not have adaptor on the component then connect to the other 3 components, the adaptor will intro conversion overhead<br></li></ul></li><li>week11 design patterns</li><li>components</li><li>top 5 architecture style<ul><li>layered architecture<ul><li>The code is arranged so the data enters the top layer and works its way down each layer until it reaches the bottom, which is usually a database. Along the way, each layer has a specific task, like checking the data for consistency or reformatting the values to keep them consistent.</li><li>view on top -- css, javascript , HTML</li><li>controller/presenter in the middle -- has various rules, methods for transforming the data moving between the view and the model</li><li>model is at the bottom -- contains business logic and information about the types of data in the database</li><li>database most bottom</li><li></li><li></li><li>advantages: (separation of concern)</li><li>maintainable--easy to update and enhance layers separately </li><li>testable</li><li>This architecture can also contain additional open layers, like a service layer, that can be used to access shared services only in the business layer but also get bypassed for speed.</li><li>should not skip past layers as it will cause tight coupling and produce a logical mess full of complex interdependencies</li><li></li><li></li></ul></li><li></li></ul></li><li>learn how to create UML diagram<br>it is used for communication only ...not a method, not a process<ul><li>diagram types <ul><li>structural (static)<ul><li>object</li><li>class</li><li>component</li><li>deployment</li><li>package</li><li>composite structure</li></ul></li><li>behavioural<ul><li>use case</li><li>sequence</li><li>communication</li><li>interaction overview</li><li>timing</li><li>state machine </li><li>activity</li></ul></li></ul></li><li>common elements in UML <ul><li>frames--used to contain diagrams</li><li>features and properties</li><li>comments/notes and constraints ( contsraints usually shown as notes ) join with a dash line and a note with dog ear , if u want constraint then write them in curly brackets</li><li>dependencies -- is like relationships<br>A---&gt;B ( A is depedent on B) ( dashed arrows )</li><li>stereotypes --elements can be extended for a specific modelling purpose<ul><li>&lt;&lt; signal &gt;&gt; </li><li>&lt;&lt; interface &gt;&gt; </li><li>&lt;&lt; enumeration &gt;&gt; </li><li></li><li>to explain more</li><li></li><li>so basically these 3 things all come from one class </li></ul></li></ul></li><li></li><li>class diagram<ul><li>classes -- a rectangle with the name(initial Capital letter) of class at the top<br>classes represent thing or events</li><li>compartments--attributes and operations</li><li>associations ( can have a 'verb' name )<br>show relationships between classes <ul><li>solid line</li></ul></li></ul></li><li></li><li>use case</li><li>sequence</li><li>component </li></ul></li><li></li><li></li><li>i havent see finish quality catalog</li><li></li><li>later just listen to architecture pattern video and write down some notes</li></ul></li></ul></body></html>